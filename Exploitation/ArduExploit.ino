/*

	############################################
	#         Jorge Rodr√≠guez Canseco          #
	#         Sergio Pastrana Portillo         #
	#                                          #
	#    Universidad Carlos III de Madrid      #
	#                                          #
	############################################
*/


#include <SoftwareSerial.h>         //Software Serial Port, it is to use another serialport and can use default Serial to debug.
#include <Process.h>
#include <avr/wdt.h>

#define soft_reset()        \
do                          \
{                           \
    wdt_enable(WDTO_15MS);  \
    for(;;)                 \
    {                       \
    }                       \
} while(0)


#define LED 13

#define RxD 10                      // This is the pin that the Bluetooth (BT_TX) will transmit to the Arduino (RxD)
#define TxD 11                      // This is the pin that the Bluetooth (BT_RX) will receive from the Arduino (TxD)
#define CONFIG_BT 0                 // 0 -> no configure bluetooth ; 1 -> configure bluetooh
#define DELAY_CONFIG_BT 1500

SoftwareSerial BTSerial(RxD, TxD);  // Setup the Arduino to receive INPUT from the bluetooth shield on Digital Pin RxD ; // Setup the Arduino to send data (OUTPUT) to the bluetooth shield on Digital Pin TxD
Process p;

// *** Bluetooth Variables ***
char ssid[15] = "ArduinoYunBT";     // BT name device. Max 20 char
char pass[5] = "1234";              // KEY to pair device. Max 4 char
char baud_rate = '4';               // Bits/second: 1=1200, 2=2400, 3=4800, 4=9600 (Por defecto), 5=19200, 6=38400, 7=57600, 8=115200, 9=230400, A=460800, B=921600, C=1382400

const int BUFF_SIZE = 20;

/* ********************* SETUP BLUETOOTH ********************* */
//The following code is necessary to setup the bluetooth shield
void setup_BT()
{
    digitalWrite(LED, HIGH); // Waiting BT connection
    Serial.println("Starting setup BT...");
    delay(5000); // X segundos para conectar el BT al arduino
    digitalWrite(LED, LOW);     // Start configuration
    
    BTSerial.print("AT"); delay(DELAY_CONFIG_BT);// This delay is required. Delay required is 1000, but we use this one for security.
    // Set BT Name
    BTSerial.print("AT+NAME"); BTSerial.print(ssid); delay(DELAY_CONFIG_BT);
    // Set BaudRate
    BTSerial.print("AT+BAUD"); BTSerial.print(baud_rate); delay(DELAY_CONFIG_BT);
    // Set Pass:
    BTSerial.print("AT+PIN"); BTSerial.print(pass); delay(DELAY_CONFIG_BT);
    // Get Version:
    //bluetooth.print("AT+VERSION"); delay(1500);
    BTSerial.flush(); // Clean serial port memory
    
    // Flicker LED to notify BT is ready
    for (int i = 0; i < 10; i++) {
        digitalWrite(LED, !digitalRead(LED));
        delay(200);
    }
    digitalWrite(LED, HIGH);
    Serial.println("Setup new configuration BT device -> OK...");
}

void setup() {
  Serial.begin(9600);    // opens serial port, sets data rate to 9600 bps
  //while (!Serial);
  delay(200);
  pinMode(LED, OUTPUT);   // Use onboard LED (if required)

    // Config Bluetooth
    BTSerial.begin(9600); //Set BluetoothBee BaudRate to default baud rate 9600
    delay(1000);
    if (CONFIG_BT == 1) {
        setup_BT();  // Start BT configuration
    } else {
        Serial.println(F("Setup old configuration in BT device -> OK "));
    }
    Serial.println(F("\nStarting Bridge..."));
  Bridge.begin();
  Serial.println(F("\nBRIDGE DONE..."));
  Serial.println(F("Setup OK...\n"));
}

void softwareReset() {
  Serial.println ("Running pwd...");
  p.runShellCommand("pwd");
}
void printEEPROM () {
  uint16_t initaddr=0;
  uint16_t endaddr=1024;
  char myChar;
  uint16_t i, j, k, remainder;
  uint8_t precision = 4;
  char tmp[16];
  char format[128];
  Serial.print ("EEPROM memory from ");
  Serial.println ((int)initaddr, HEX);

  sprintf(format, "0x%%.%dX", 4);
  sprintf(tmp, format, initaddr);
  Serial.print(tmp);
  Serial.print("\t");
  k = 0;
  char* truncated;
  for (i = initaddr; i <= endaddr; i++, k++) {
    if (k % 16 == 0 && k != 0) {
      Serial.print("\t");
      for (j = i - 16; j < i; j++) {
        //address=(uint8_t*)j;
        myChar =  eeprom_read_byte((uint8_t*)(initaddr + j));
        if (((uint8_t)myChar < 0x20) || ((uint8_t)myChar > 0x7e))
          Serial.print(".");
        else
          Serial.print (myChar);
      }
      Serial.println();
      sprintf(format, "0x%%.%dX", 4);
      sprintf(tmp, format, i);
      Serial.print(tmp);

      // Serial.print (i,HEX);
      Serial.print ("\t");
    } else if (k % 8 == 0 && k != 0) {
      Serial.print("  ");
    }
    
    myChar =  eeprom_read_byte((uint8_t*)(initaddr + i));
    sprintf(format, "%%.%dX", precision);
    sprintf(tmp, format, myChar);
    
    Serial.print((char)*(tmp+2));
    Serial.print((char)*(tmp+3));
    Serial.print (" ");
  }
  i = k;
  remainder = 0;
  // Pad out last line if not exactly 16 characters.
  while ((k % 16) != 0) {
    Serial.print ("   ");
    if (k % 8 == 0)
      Serial.print("  ");
    k++;
    remainder++;
  }
  Serial.print ("\t");
  for (j = endaddr - 16 + remainder; j < endaddr; j++) {
    myChar =  eeprom_read_byte((uint8_t*)(initaddr + j));
    if (((uint8_t)myChar < 0x20) || ((uint8_t)myChar > 0x7e))
      Serial.print(".");
    else
      Serial.print (myChar);
  }
  Serial.println ();
}

void printFlashMemory (uint8_t* initaddr, uint8_t* endaddr) {
  char myChar;
  if (endaddr == (int)0)
    endaddr = (uint8_t*)0x7FFE;
  int i, j, k, remainder;
  int precision = 4;
  char tmp[16];
  char format[128];
  Serial.print ("Flash memory from ");
  Serial.println ((int)initaddr, HEX);

  sprintf(format, "0x%%.%dX", 4);
  sprintf(tmp, format, (int)initaddr);
  Serial.print(tmp);
  Serial.print("\t");
  k = 0;
  char* truncated;
  for (i = (int)initaddr; i <= (int)endaddr; i++, k++) {

    if (k % 16 == 0 && k != 0) {
      Serial.print("\t");
      for (j = i - 16; j < i; j++) {
        //address=(uint8_t*)j;
        myChar =  pgm_read_byte_near(initaddr + j);
        if (((int)myChar < 0x20) || ((int)myChar > 0x7e))
          Serial.print(".");
        else
          Serial.print (myChar);
      }
      Serial.println();
      sprintf(format, "0x%%.%dX", 4);
      sprintf(tmp, format, i);
      Serial.print(tmp);

      Serial.print ("\t");
    } else if (k % 8 == 0 && k != 0) {
      Serial.print("  ");
    }
    
    myChar =  pgm_read_byte_near(initaddr + i);
    sprintf(format, "%%.%dX", precision);
    sprintf(tmp, format, myChar);
    
    Serial.print((char)*(tmp+2)); Serial.print((char)*(tmp+3));
    Serial.print (" ");
  }
  i = k;
  remainder = 0;
  // Pad out last line if not exactly 16 characters.
  while ((k % 16) != 0) {
    Serial.print ("   ");
    if (k % 8 == 0)
      Serial.print("  ");
    k++;
    remainder++;
  }
  Serial.print ("\t");
  for (j = (int)endaddr - 16 + remainder; j < (int)endaddr; j++) {
    myChar =  pgm_read_byte_near(initaddr + j);
    if (((int)myChar < 0x20) || ((int)myChar > 0x7e))
      Serial.print(".");
    else
      Serial.print (myChar);
  }
  Serial.println ();
}


void printSRAM(uint8_t* initaddr, uint8_t* endaddr) {
  uint8_t* address;
  int i, j;
  int k = 0;
  int remainder;
  if ((int)endaddr == 0)
    endaddr = (uint8_t*)0xAFF;
  Serial.print ("Stack Pointer:");
  Serial.println(SP,HEX);
  Serial.print ("SRAM from ");
  Serial.println ((int)initaddr, HEX);
  Serial.print ((int)initaddr, HEX);
  Serial.print("\t");
  for (i = (int)initaddr; i <= (int)endaddr; i++, k++) {
    if (k % 16 == 0 && k != 0) {
      Serial.print("\t");
      for (j = i - 16; j < i; j++) {
        address = (uint8_t*)j;
        if (((int)*address < 0x20) || ((int)*address > 0x7e))
          Serial.print(".");
        else
          Serial.print ((char)(*address));
      }
      Serial.println();
      Serial.print (i, HEX);
      Serial.print ("\t");
    } else if (k % 8 == 0 && k != 0) {
      Serial.print("  ");
    }
    address = (uint8_t*)i;
    if ((int)*address < 0x10)
      Serial.print("0");
    Serial.print(*address, HEX);
    Serial.print (" ");
  }
  i = k;
  remainder = 0;
  // Pad out last line if not exactly 16 characters.
  while ((k % 16) != 0) {
    Serial.print ("   ");
    if (k % 8 == 0)
      Serial.print("  ");
    k++;
    remainder++;
  }
  Serial.print ("\t");
  for (j = (int)endaddr - 16 + remainder; j < (int)endaddr; j++) {
    address = (uint8_t*)j;
    if (((int)*address < 0x20) || ((int)*address > 0x7e))
      Serial.print(".");
    else
      Serial.print ((char)(*address));
  }
  Serial.println ();
}
void printStack(int initAddr) {
  void* initaddr = (void*)initAddr;
  uint8_t* address;
  int i, j;
  int k = 0;
  int remainder;
  uint8_t*  endaddr = (uint8_t*)0xAFF;

  Serial.println ("STACK:");
  Serial.print("0x");
  Serial.print ((int)initaddr, HEX);
  Serial.print("\t");
  for (i = (int)initaddr; i <= (int)endaddr; i++, k++) {
    if (k % 16 == 0 && k != 0) {
      Serial.print("\t");
      for (j = i - 16; j < i; j++) {
        address = (uint8_t*)j;
        if (((int)*address < 0x20) || ((int)*address > 0x7e))
          Serial.print(".");
        else
          Serial.print ((char)(*address));
      }
      Serial.println();
      Serial.print("0x");
      Serial.print (i, HEX);
      Serial.print ("\t");
    } else if (k % 8 == 0 && k != 0) {
      Serial.print("  ");
    }
    address = (uint8_t*)i;
    if ((int)*address < 0x10)
      Serial.print("0");
    Serial.print(*address, HEX);
    Serial.print (" ");
  }
  i = k;
  remainder = 0;
  // Pad out last line if not exactly 16 characters.
  while ((k % 16) != 0) {
    Serial.print ("   ");
    if (k % 8 == 0)
      Serial.print("  ");
    k++;
    remainder++;
  }
  Serial.print ("\t");
  for (j = (int)endaddr - 16 + remainder; j < (int)endaddr; j++) {
    address = (uint8_t*)j;
    if (((int)*address < 0x20) || ((int)*address > 0x7e))
      Serial.print(".");
    else
      Serial.print ((char)(*address));
  }
  Serial.println ();
}


int vulnerable_func () {
  volatile uint8_t tmp_buff [BUFF_SIZE];
  int i;

  printStack(SP);
  while (!BTSerial.available());
  i = 0;
  while (BTSerial.available() > 0) {
    char c = BTSerial.read();  //gets one byte from serial buffer
    tmp_buff[i] = c;
    i++;
    delay(25); // Wait for the serial buffer to receive 
  }
  if (tmp_buff == NULL)
    return -1;
  printStack(SP);
  return 0;
}


void showOutputProcess() {
  while (p.running());

  Serial.println();
  while (p.available() > 0) {
    char c = p.read();
    Serial.print(c);
  }
  Serial.flush();
}

void processCommand(){
  //execute the command
    p.runShellCommand("ifconfig"); 
    showOutputProcess();
}


void loop() {
  // put your main code here, to run repeatedly:
  char option;
  Serial.println ("What do you want?");
  Serial.println ("1. Dump SRAM");
  Serial.println ("2. Dump Flash");
  Serial.println ("3. Dump EEPROM");
  Serial.println ("4. Run Vulnerable Function");
  Serial.println ("5. Software Reset");
  Serial.println ("6. Get network info");
  while (!BTSerial.available());

  option = BTSerial.read();  //gets one byte from serial buffer


  if (option == '1') {
    printSRAM((uint8_t*)0, (uint8_t*)0);
  } else if (option == '2') {
    printFlashMemory((uint8_t*)0, (uint8_t*)0);
  }else if (option=='3'){
    printEEPROM();
  } else if (option == '5') {
    Serial.println("Going to SW reset...");
    soft_reset();
  } else if (option == '4') {
    Serial.print ("Running vulnerable function...");
    int r = vulnerable_func ();
    Serial.print ("Vulnerable function ");
    if (r >= 0)
      Serial.println("OK");
    else
      Serial.println ("KO");
  }else if (option == '6'){
    processCommand();
  } else {
    Serial.print("Wrong option: ");
    Serial.println(option);
  }
}



